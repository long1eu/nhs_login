import 'dart:math';

import 'package:http/http.dart';
import 'package:meta/meta.dart';
import 'package:nhs_login/nhs_login.dart';
import 'package:nhs_login/src/models/authentication/nhs_display.dart';
import 'package:nhs_login/src/models/authentication/nhs_prompt.dart';
import 'package:nhs_login/src/models/authentication/nhs_scope.dart';
import 'package:nhs_login/src/models/authentication/nhs_vector_or_trust.dart';

/// The client initiates an authentication request to the NHS Digital NHS login
/// authorize endpoint using the HTTP GET or POST methods.
///
/// If using HTTP GET, then the parameters are serialised using URI query
/// Serialisation. In the case of HTTP POST, then the parameters are serialised
/// using Form Serialisation
class NhsAuthentication {
  NhsAuthentication({
    @required this.scopes,
    this.host,
    this.clientId,
    this.redirectUri,
    String state,
    String nonce,
    this.display = NhsDisplay.page,
    this.prompt,
    this.vectorOfTrust,
    this.fidoAuthResponse,
    this.assertedLoginIdentity,
    this.allowRegistration,
  })  : assert(scopes.isNotEmpty && scopes.contains(NhsScope.openId)),
        /*assert(!redirectUri.startsWith('http') || redirectUri.startsWith('https')),*/
        state = state ?? _randomString(),
        nonce = nonce ?? _randomString();

  static const String responseType = 'code';

  /// The host of the NHS Server
  final String host;

  /// Request that specific sets of information be made available as Claim
  /// Values when making an Authentication Request
  final List<NhsScope> scopes;

  /// OAuth 2.0 Client Identifier
  ///
  /// This is a static identifier previously provided by the NHS login Partner
  /// Onboarding team
  final String clientId;

  /// Redirection URI to which the response will be sent.
  ///
  /// This URI MUST exactly match one of the Redirection URI values for the
  /// Client pre-registered at the OpenID Provider. When using this flow,
  /// the Redirection URI MUST NOT use the http scheme. The Redirection URI MAY
  /// use an alternate scheme, such as one that is intended to identify a
  /// callback into a native application
  final String redirectUri;

  /// Opaque value used to maintain state between the request and the callback.
  ///
  /// Typically, Cross-Site Request Forgery (CSRF, XSRF) mitigation is done by
  /// cryptographically binding the value of this parameter with a browser
  /// cookie.
  ///
  /// This value will be returned to the client in the authentication response.
  /// The iGov profile for OIDC specifies this parameter as Mandatory to help
  /// RPs protect against CSRF attacks.
  final String state;

  /// String value used to associate a Client session with an ID Token, and to
  /// mitigate replay attacks.
  ///
  /// The value is passed through unmodified from the
  /// Authentication Request to the ID Token. Sufficient entropy MUST be present
  /// in the nonce values used to prevent attackers from guessing values. The
  /// iGov profile for OIDC specifies this parameter as Mandatory to help RPs
  /// protect against CSRF attacks.
  final String nonce;

  /// Specifies how the Platform displays the authentication and consent user
  /// interface pages to the End-User.
  ///
  /// NOTE: [NhsDisplay.popup] and [NhsDisplay.wap] values are not supported
  final NhsDisplay display;

  /// Requests that the NHS login Service forces the user to sign-in, or to
  /// request that the Service does not prompt the user to sign-in (SSO)
  final NhsPrompt prompt;

  /// Vector of Trust Request – requested levels of Identity Verification and
  /// Authentication.
  ///
  /// Defaults to “[“P9.Cp.Cd”,“P9.Cp.Ck”,“P9.Cm”]” being assumed
  final NhsVectorOfTrust vectorOfTrust;

  /// Base64 URL-encoded FIDO UAF AuthResponse message generated by FIDO client
  /// on a registered device
  final String fidoAuthResponse;

  /// The purpose of this parameter is to support seamless login between two RPs
  /// (RP1 and RP2) where cookie-based SSO is not available. The content will be
  /// a signed jwt with payload containing “code” attribute with the value being
  /// that of the “jti” attribute from the ID Token issued to RP1. The jwt “iss”
  /// attribute MUST contain the client_id of RP1, the jwt MUST have an “exp” of
  /// no longer that 60 seconds, MUST have “jti” and “iat” attributes
  /// (as per RFC7519) and MUST be signed by RP1 using its client private key.
  /// RP1 passes the jwt to RP2 for RP2 to use in its authentication request.
  ///
  /// A non-normative example jwt payload section is as follows
  /// ```json
  /// {
  ///   "code": "eeroifoteiwrudjdwusdu",
  ///   "iss": "client1",
  ///   "jti": "reioteotijdvorijevoihroi",
  ///   "iat": 1548701645,
  ///   "exp": 1548701705
  /// }
  /// ```
  final String assertedLoginIdentity;

  /// If [false], will hide links to account registration screens in the NHS
  /// login UI.
  final bool allowRegistration;

  Uri get uri {
    assert(host != null && host.isNotEmpty);

    return Uri(
      scheme: 'https',
      host: host,
      path: 'authorize',
      queryParameters: _params,
    );
  }

  Request get request {
    return Request('POST', Uri(scheme: 'https', host: host, path: 'authorize'))
      ..bodyFields = _params;
  }

  Map<String, dynamic> get _params {
    assert(clientId != null && clientId.isNotEmpty);
    assert(redirectUri != null && redirectUri.isNotEmpty);
    assert(state != null && state.isNotEmpty);
    assert(nonce != null && nonce.isNotEmpty);

    final Map<String, dynamic> params = <String, dynamic>{
      'scope': scopes.join(' '),
      'response_type': responseType,
      'client_id': clientId,
      'redirect_uri': redirectUri,
      'state': state,
      'nonce': nonce,
    };

    if (display != null) {
      params['display'] = display.value;
    }

    if (prompt != null) {
      params['prompt'] = prompt.value;
    }

    if (vectorOfTrust != null) {
      params['vtr'] = vectorOfTrust.toString();
    }

    if (fidoAuthResponse != null) {
      params['fido_auth_response'] = fidoAuthResponse;
    }

    if (assertedLoginIdentity != null) {
      params['asserted_login_identity'] = assertedLoginIdentity;
    }

    if (allowRegistration != null) {
      params['allow_registration'] = allowRegistration.toString();
    }

    return params;
  }

  NhsAuthentication copyWith({
    String host,
    List<NhsScope> scopes,
    String clientId,
    String redirectUri,
    String state,
    String nonce,
    NhsDisplay display,
    NhsPrompt prompt,
    List<NhsVectorOfTrust> vectorOfTrust,
    String fidoAuthResponse,
    String assertedLoginIdentity,
    bool allowRegistration,
  }) {
    return NhsAuthentication(
      host: host ?? this.host,
      scopes: scopes ?? this.scopes,
      clientId: clientId ?? this.clientId,
      redirectUri: redirectUri ?? this.redirectUri,
      state: state ?? this.state,
      nonce: nonce ?? this.nonce,
      display: display ?? this.display,
      prompt: prompt ?? this.prompt,
      vectorOfTrust: vectorOfTrust ?? this.vectorOfTrust,
      fidoAuthResponse: fidoAuthResponse ?? this.fidoAuthResponse,
      assertedLoginIdentity:
          assertedLoginIdentity ?? this.assertedLoginIdentity,
      allowRegistration: allowRegistration ?? this.allowRegistration,
    );
  }

  NhsAuthentication mergeWith(NhsLogin nhsLogin) {
    return copyWith(
      host: host ?? nhsLogin.host,
      clientId: clientId ?? nhsLogin.clientId,
      redirectUri: redirectUri ?? nhsLogin.redirectUri,
    );
  }
}

String _randomString() {
  final Random r = Random.secure();
  final List<int> chars =
      '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
          .codeUnits;
  final Iterable<int> result =
      Iterable<int>.generate(50, (_) => chars[r.nextInt(chars.length)]);
  return String.fromCharCodes(result);
}
